При запуске в фоновом режиме (`ircbot &`) продолжает быть привязанной к терминалу. Когда программа работает в фоне, она может сталкиваться с проблемами из-за:

1. **Сигнала SIGHUP**: Когда терминал закрывается или отключается, программа получает сигнал `SIGHUP` (Hangup), что приводит к её завершению.
2. **Ввод/вывод**: Если программа пытается читать из стандартного ввода (`stdin`) или записывать в стандартный вывод (`stdout`), это может вызвать блокировку или зависание.

---

### Решения проблемы:

#### 1. **Использование утилиты `nohup`**
`nohup` — это команда Linux, которая позволяет программе игнорировать сигнал `SIGHUP` и продолжать работу даже после закрытия терминала.

**Как использовать:**
```bash
nohup ./ircbot > output.log 2>&1 &
```

- `nohup`: Заставляет программу игнорировать сигнал `SIGHUP`.
- `> output.log`: Перенаправляет стандартный вывод в файл `output.log`.
- `2>&1`: Перенаправляет стандартные ошибки (`stderr`) в тот же файл, что и стандартный вывод.
- `&`: Запускает программу в фоновом режиме.

Теперь программа будет работать в фоне, даже если вы закроете терминал.

---

#### 2. **Отключение стандартного ввода/вывода**
Если ваша программа не использует `stdin`, `stdout` или `stderr`, их можно явно перенаправить в `/dev/null`. Это предотвратит возможные проблемы с блокировкой.

**Как использовать:**
```bash
./ircbot < /dev/null > /dev/null 2>&1 &
```

- `< /dev/null`: Отключает стандартный ввод.
- `> /dev/null`: Отключает стандартный вывод.
- `2>&1`: Перенаправляет стандартные ошибки в тот же поток, что и стандартный вывод.
- `&`: Запускает программу в фоновом режиме.

---

#### 3. **Демонизация программы**
Если вы хотите, чтобы программа работала как системный сервис (демон), её нужно правильно "демонизировать". Это означает:
- Отвязать программу от терминала.
- Закрыть дескрипторы `stdin`, `stdout` и `stderr`.
- Игнорировать сигнал `SIGHUP`.

**Пример кода для демонизации:**

```cpp
#include <iostream>
#include <unistd.h>
#include <sys/types.h>
#include <signal.h>

void daemonize() {
    // Создаем новый процесс
    pid_t pid = fork();
    if (pid < 0) {
        std::cerr << "Fork failed!" << std::endl;
        exit(1);
    }
    if (pid > 0) {
        exit(0); // Завершаем родительский процесс
    }

    // Создаем новую сессию и отсоединяемся от терминала
    setsid();

    // Игнорируем сигнал SIGHUP
    signal(SIGHUP, SIG_IGN);

    // Закрываем стандартные дескрипторы
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);

    // Перенаправляем stdout и stderr в /dev/null
    open("/dev/null", O_RDONLY);  // stdin
    open("/dev/null", O_WRONLY);  // stdout
    open("/dev/null", O_WRONLY);  // stderr
}

int main() {
    daemonize(); // Демонизируем программу

    // Основной код программы
    while (true) {
        std::cout << "IRC Bot is running..." << std::endl;
        sleep(5); // Имитация работы
    }

    return 0;
}
```

**Как это работает:**
1. `fork()` создаёт дочерний процесс, который становится независимым от терминала.
2. `setsid()` создаёт новую сессию, отсоединяясь от родительского терминала.
3. `close()` закрывает стандартные дескрипторы (`stdin`, `stdout`, `stderr`).
4. Программа больше не зависит от терминала и может работать в фоне.

---

#### 4. **Использование systemd или screen/tmux**
Если вы хотите управлять программой как системным сервисом, можно создать службу для неё с помощью `systemd`.

**Шаги:**
1. Создайте файл службы `/etc/systemd/system/ircbot.service`:
   ```ini
   [Unit]
   Description=IRC Bot Service
   After=network.target

   [Service]
   ExecStart=/путь/к/ircbot
   Restart=always
   StandardOutput=null
   StandardError=null

   [Install]
   WantedBy=multi-user.target
   ```

2. Обновите конфигурацию `systemd`:
   ```bash
   sudo systemctl daemon-reload
   ```

3. Запустите службу:
   ```bash
   sudo systemctl start ircbot
   ```

4. Включите автозапуск:
   ```bash
   sudo systemctl enable ircbot
   ```

Альтернативно, можно использовать `screen` или `tmux` для запуска программы в фоне с возможностью подключения к сессии позже:
```bash
screen -dmS ircbot ./ircbot
# или
tmux new -d -s ircbot './ircbot'
```

---

#### 5. **Отключение автоматического завершения при SIGHUP**
Вы можете настроить терминал так, чтобы он не отправлял сигнал `SIGHUP` при закрытии:
```bash
shopt -s huponexit
```
Однако этот подход менее надёжен, чем использование `nohup` или демонизации.

---

### Рекомендации:

- Если программа должна работать как фоновый процесс, лучше всего использовать **`nohup`** или **демонизацию**.
- Для управления программой как системным сервисом рекомендуется использовать **`systemd`**.
- Если вам нужен доступ к выводу программы в реальном времени, используйте **`screen`** или **`tmux`**.

---

### Пример запуска с `nohup`:
```bash
nohup ./ircbot > ircbot.log 2>&1 &
```

Это запустит программу в фоне, а всё её вывод будет записан в файл `ircbot.log`. Вы также сможете проверить логи, если возникнут проблемы.